//! SquirrelDB Rust SDK - Query Builder
//! Generated by sdk-generator v0.1.0
//! DO NOT EDIT MANUALLY

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Sort direction
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum SortDirection {
    Asc,
    Desc,
}

impl Default for SortDirection {
    fn default() -> Self {
        Self::Asc
    }
}

/// A single filter condition
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FilterCondition {
    pub field: String,
    pub operator: String,
    pub value: serde_json::Value,
}

/// Sort specification for a field
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SortSpec {
    pub field: String,
    pub direction: SortDirection,
}

/// Options for change subscriptions
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ChangesOptions {
    #[serde(default = "default_true")]
    pub include_initial: bool,
}

fn default_true() -> bool {
    true
}

/// Structured query object (wire format)
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct StructuredQuery {
    pub table: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub filter: Option<HashMap<String, HashMap<String, serde_json::Value>>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sort: Option<Vec<SortSpec>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub limit: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub skip: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub changes: Option<ChangesOptions>,
}

/// Field expression for building filter conditions
#[derive(Debug, Clone)]
pub struct FieldExpr {
    field_name: String,
}

impl FieldExpr {
    /// Create a new field expression
    pub fn new(name: impl Into<String>) -> Self {
        Self {
            field_name: name.into(),
        }
    }

    /// Equal to
    pub fn eq(self, value: impl Into<serde_json::Value>) -> FilterCondition {
        FilterCondition {
            field: self.field_name,
            operator: "$eq".to_string(),
            value: value.into(),
        }
    }

    /// Not equal to
    pub fn ne(self, value: impl Into<serde_json::Value>) -> FilterCondition {
        FilterCondition {
            field: self.field_name,
            operator: "$ne".to_string(),
            value: value.into(),
        }
    }

    /// Greater than
    pub fn gt(self, value: impl Into<serde_json::Value>) -> FilterCondition {
        FilterCondition {
            field: self.field_name,
            operator: "$gt".to_string(),
            value: value.into(),
        }
    }

    /// Greater than or equal to
    pub fn gte(self, value: impl Into<serde_json::Value>) -> FilterCondition {
        FilterCondition {
            field: self.field_name,
            operator: "$gte".to_string(),
            value: value.into(),
        }
    }

    /// Less than
    pub fn lt(self, value: impl Into<serde_json::Value>) -> FilterCondition {
        FilterCondition {
            field: self.field_name,
            operator: "$lt".to_string(),
            value: value.into(),
        }
    }

    /// Less than or equal to
    pub fn lte(self, value: impl Into<serde_json::Value>) -> FilterCondition {
        FilterCondition {
            field: self.field_name,
            operator: "$lte".to_string(),
            value: value.into(),
        }
    }

    /// Value in array
    pub fn is_in(self, values: Vec<serde_json::Value>) -> FilterCondition {
        FilterCondition {
            field: self.field_name,
            operator: "$in".to_string(),
            value: serde_json::Value::Array(values),
        }
    }

    /// Value not in array
    pub fn not_in(self, values: Vec<serde_json::Value>) -> FilterCondition {
        FilterCondition {
            field: self.field_name,
            operator: "$nin".to_string(),
            value: serde_json::Value::Array(values),
        }
    }

    /// String contains substring
    pub fn contains(self, value: impl Into<String>) -> FilterCondition {
        FilterCondition {
            field: self.field_name,
            operator: "$contains".to_string(),
            value: serde_json::Value::String(value.into()),
        }
    }

    /// String starts with prefix
    pub fn starts_with(self, value: impl Into<String>) -> FilterCondition {
        FilterCondition {
            field: self.field_name,
            operator: "$startsWith".to_string(),
            value: serde_json::Value::String(value.into()),
        }
    }

    /// String ends with suffix
    pub fn ends_with(self, value: impl Into<String>) -> FilterCondition {
        FilterCondition {
            field: self.field_name,
            operator: "$endsWith".to_string(),
            value: serde_json::Value::String(value.into()),
        }
    }

    /// Field exists (or not)
    pub fn exists(self, value: bool) -> FilterCondition {
        FilterCondition {
            field: self.field_name,
            operator: "$exists".to_string(),
            value: serde_json::Value::Bool(value),
        }
    }
}

/// Create a field expression for filtering
pub fn field(name: impl Into<String>) -> FieldExpr {
    FieldExpr::new(name)
}

/// Query builder for constructing SquirrelDB queries
#[derive(Debug, Clone, Default)]
pub struct QueryBuilder {
    table_name: String,
    filters: Vec<FilterCondition>,
    sorts: Vec<SortSpec>,
    limit_value: Option<i64>,
    skip_value: Option<i64>,
    changes_opts: Option<ChangesOptions>,
}

impl QueryBuilder {
    /// Create a new query builder for a table
    pub fn new(table_name: impl Into<String>) -> Self {
        Self {
            table_name: table_name.into(),
            ..Default::default()
        }
    }

    /// Add a filter condition
    pub fn find(mut self, condition: FilterCondition) -> Self {
        self.filters.push(condition);
        self
    }

    /// Add multiple filter conditions
    pub fn find_all(mut self, conditions: Vec<FilterCondition>) -> Self {
        self.filters.extend(conditions);
        self
    }

    /// Add a sort specification
    pub fn sort(mut self, field_name: impl Into<String>, direction: SortDirection) -> Self {
        self.sorts.push(SortSpec {
            field: field_name.into(),
            direction,
        });
        self
    }

    /// Set maximum number of results
    pub fn limit(mut self, n: i64) -> Self {
        self.limit_value = Some(n);
        self
    }

    /// Set number of results to skip
    pub fn skip(mut self, n: i64) -> Self {
        self.skip_value = Some(n);
        self
    }

    /// Subscribe to changes
    pub fn changes(mut self, opts: Option<ChangesOptions>) -> Self {
        self.changes_opts = Some(opts.unwrap_or(ChangesOptions {
            include_initial: true,
        }));
        self
    }

    /// Compile to structured query object
    pub fn compile_structured(self) -> StructuredQuery {
        let filter = if self.filters.is_empty() {
            None
        } else {
            Some(self.build_filter_object())
        };

        let sort = if self.sorts.is_empty() {
            None
        } else {
            Some(self.sorts)
        };

        StructuredQuery {
            table: self.table_name,
            filter,
            sort,
            limit: self.limit_value,
            skip: self.skip_value,
            changes: self.changes_opts,
        }
    }

    /// Compile to JSON string
    pub fn compile(self) -> Result<String, serde_json::Error> {
        serde_json::to_string(&self.compile_structured())
    }

    fn build_filter_object(&self) -> HashMap<String, HashMap<String, serde_json::Value>> {
        let mut filter_obj: HashMap<String, HashMap<String, serde_json::Value>> = HashMap::new();
        for cond in &self.filters {
            filter_obj
                .entry(cond.field.clone())
                .or_default()
                .insert(cond.operator.clone(), cond.value.clone());
        }
        filter_obj
    }
}

/// Create a new query builder for a table
pub fn table(name: impl Into<String>) -> QueryBuilder {
    QueryBuilder::new(name)
}

/// Combine conditions with AND
pub fn and(conditions: Vec<FilterCondition>) -> FilterCondition {
    FilterCondition {
        field: "$and".to_string(),
        operator: "$and".to_string(),
        value: serde_json::to_value(conditions).unwrap_or(serde_json::Value::Array(vec![])),
    }
}

/// Combine conditions with OR
pub fn or(conditions: Vec<FilterCondition>) -> FilterCondition {
    FilterCondition {
        field: "$or".to_string(),
        operator: "$or".to_string(),
        value: serde_json::to_value(conditions).unwrap_or(serde_json::Value::Array(vec![])),
    }
}

/// Negate a condition
pub fn not(condition: FilterCondition) -> FilterCondition {
    FilterCondition {
        field: "$not".to_string(),
        operator: "$not".to_string(),
        value: serde_json::to_value(condition).unwrap_or(serde_json::Value::Null),
    }
}
